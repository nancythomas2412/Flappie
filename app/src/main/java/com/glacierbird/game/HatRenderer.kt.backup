package com.glacierbird.game

import android.graphics.*

/**
 * HatRenderer - Beautiful hat selection and showcase UI
 * Achievement-based cosmetic system
 */
class HatRenderer(
    private val screenWidth: Int,
    private val screenHeight: Int
) {
    
    // Background and panels
    private val overlayPaint = Paint().apply {
        color = Color.parseColor("#F0000000") // Slightly darker overlay for focus
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val panelPaint = Paint().apply {
        color = Color.WHITE
        style = Paint.Style.FILL
        isAntiAlias = true
        setShadowLayer(20f, 0f, 10f, Color.parseColor("#60000000"))
    }
    
    // Title and text (elderly-friendly sizes)
    private val titlePaint = Paint().apply {
        color = Color.parseColor("#2C3E50")
        textSize = GameConstants.LARGE_TEXT_SIZE
        typeface = Typeface.DEFAULT_BOLD
        textAlign = Paint.Align.CENTER
        isAntiAlias = true
    }
    
    // Removed unused sectionTitlePaint
    
    private val hatNamePaint = Paint().apply {
        color = Color.parseColor("#2C3E50")
        textSize = GameConstants.SMALL_TEXT_SIZE
        typeface = Typeface.DEFAULT_BOLD
        textAlign = Paint.Align.CENTER
        isAntiAlias = true
    }
    
    private val hatDescPaint = Paint().apply {
        color = Color.parseColor("#5D6D7E")
        textSize = GameConstants.TINY_TEXT_SIZE
        typeface = Typeface.DEFAULT
        textAlign = Paint.Align.CENTER
        isAntiAlias = true
    }
    
    // Removed unused pricePaint
    
    // Hat card backgrounds
    private val unlockedCardPaint = Paint().apply {
        color = Color.parseColor("#FFFFFF")
        style = Paint.Style.FILL
        isAntiAlias = true
        setShadowLayer(8f, 0f, 4f, Color.parseColor("#40000000"))
    }
    
    private val selectedCardPaint = Paint().apply {
        color = Color.parseColor("#E8F5E8")
        style = Paint.Style.FILL
        isAntiAlias = true
        setShadowLayer(8f, 0f, 4f, Color.parseColor("#40000000"))
    }
    
    private val lockedCardPaint = Paint().apply {
        color = Color.parseColor("#F8F9FA")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    // Borders
    private val selectedBorderPaint = Paint().apply {
        color = Color.parseColor("#27AE60")
        style = Paint.Style.STROKE
        strokeWidth = 4f
        isAntiAlias = true
    }
    
    private val rarityBorderPaints = mapOf(
        HatRarity.COMMON to Paint().apply {
            color = Color.parseColor(HatRarity.COMMON.color)
            style = Paint.Style.STROKE
            strokeWidth = 3f
            isAntiAlias = true
        },
        HatRarity.RARE to Paint().apply {
            color = Color.parseColor(HatRarity.RARE.color)
            style = Paint.Style.STROKE
            strokeWidth = 3f
            isAntiAlias = true
        },
        HatRarity.EPIC to Paint().apply {
            color = Color.parseColor(HatRarity.EPIC.color)
            style = Paint.Style.STROKE
            strokeWidth = 3f
            isAntiAlias = true
        },
        HatRarity.LEGENDARY to Paint().apply {
            color = Color.parseColor(HatRarity.LEGENDARY.color)
            style = Paint.Style.STROKE
            strokeWidth = 3f
            isAntiAlias = true
        }
    )
    
    // Buttons
    private val selectButtonPaint = Paint().apply {
        color = Color.parseColor("#27AE60")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val buyButtonPaint = Paint().apply {
        color = Color.parseColor("#3498DB")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val buttonTextPaint = Paint().apply {
        color = Color.WHITE
        textSize = GameConstants.TINY_TEXT_SIZE
        typeface = Typeface.DEFAULT_BOLD
        textAlign = Paint.Align.CENTER
        isAntiAlias = true
    }
    
    // Close button (much larger)
    private val closeButtonPaint = Paint().apply {
        color = Color.parseColor("#E74C3C")  // More visible red color
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val closeButtonTextPaint = Paint().apply {
        color = Color.WHITE
        textSize = GameConstants.SMALL_TEXT_SIZE
        typeface = Typeface.DEFAULT_BOLD
        textAlign = Paint.Align.CENTER
        isAntiAlias = true
    }
    
    // Lock overlay
    private val lockOverlayPaint = Paint().apply {
        color = Color.parseColor("#80000000")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val lockIconPaint = Paint().apply {
        color = Color.parseColor("#FFFFFF")
        textSize = GameConstants.SMALL_TEXT_SIZE
        typeface = Typeface.DEFAULT_BOLD
        textAlign = Paint.Align.CENTER
        isAntiAlias = true
    }
    
    // Sprite painting - static Paint objects to avoid recreation
    private val bodyPaint = Paint().apply {
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val outlinePaint = Paint().apply {
        color = Color.parseColor("#2C3E50")
        style = Paint.Style.STROKE
        strokeWidth = 3f
        isAntiAlias = true
    }
    
    private val eyePaint = Paint().apply {
        color = Color.WHITE
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val pupilPaint = Paint().apply {
        color = Color.BLACK
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val beakPaint = Paint().apply {
        color = Color.parseColor("#F39C12")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    // Special effects Paint objects
    private val sparklePaint = Paint().apply {
        color = Color.parseColor("#FFFF00")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val magicPaint = Paint().apply {
        color = Color.parseColor("#9400D3")
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val gridPaint = Paint().apply {
        color = Color.parseColor("#00FFFF")
        style = Paint.Style.STROKE
        strokeWidth = 1f
        isAntiAlias = true
        alpha = 128
    }
    
    private val runePaint = Paint().apply {
        color = Color.parseColor("#4682B4")
        style = Paint.Style.STROKE
        strokeWidth = 2f
        isAntiAlias = true
    }
    
    // Rarity text paint (reusable for different colors)
    private val rarityTextPaint = Paint().apply {
        textSize = GameConstants.TINY_TEXT_SIZE
        typeface = Typeface.DEFAULT_BOLD
        textAlign = Paint.Align.CENTER
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    /**
     * Draw hat selection screen
     */
    fun drawHatSelectionScreen(
        canvas: Canvas,
        hatInfoList: List<HatInfo>,
        collectionStats: HatCollectionStats,
        scrollOffset: Float = 0f
    ) {
        // Overlay
        canvas.drawColor(overlayPaint.color)
        
        // Larger main panel with better padding
        val panelWidth = screenWidth * 0.92f
        val panelHeight = screenHeight * 0.85f
        val panelX = (screenWidth - panelWidth) / 2f
        val panelY = (screenHeight - panelHeight) / 2f
        
        val panelRect = RectF(panelX, panelY, panelX + panelWidth, panelY + panelHeight)
        canvas.drawRoundRect(panelRect, 25f, 25f, panelPaint)
        
        // Title with more space
        canvas.drawText("ðŸŽ© Hat Collection", screenWidth / 2f, panelY + 80f, titlePaint)
        
        // Collection stats with better spacing
        val statsText = "${collectionStats.unlockedHats}/${collectionStats.totalHats} Collected (${collectionStats.collectionPercentage}%)"
        canvas.drawText(statsText, screenWidth / 2f, panelY + 140f, hatDescPaint)
        
        // Close button (larger and properly positioned)
        drawCloseButton(canvas, panelX + panelWidth - 100f, panelY + 30f)
        
        // Content area with more padding
        val contentStartY = panelY + 190f     // Increased spacing from 170f
        val contentWidth = panelWidth - 80f   // More padding from 60f
        val contentX = panelX + 40f           // More padding from 30f
        
        // Apply scroll offset and clipping with better bounds
        canvas.save()
        canvas.clipRect(
            panelX + 10f,
            contentStartY,
            panelX + panelWidth - 10f,
            panelY + panelHeight - 30f
        )
        drawHatGrid(canvas, hatInfoList, contentX, contentStartY + scrollOffset, contentWidth)
        canvas.restore()
    }
    
    /**
     * Draw hat grid layout
     */
    private fun drawHatGrid(
        canvas: Canvas,
        hatInfoList: List<HatInfo>,
        startX: Float,
        startY: Float,
        gridWidth: Float
    ) {
        val itemsPerRow = 2
        val cardWidth = (gridWidth - 60f) / itemsPerRow // Even more spacing
        val cardHeight = 290f  // Taller cards for better content fit
        val spacing = 40f      // Much more generous spacing
        
        var currentX = startX
        var currentY = startY
        var itemsInCurrentRow = 0
        
        hatInfoList.forEachIndexed { _, hatInfo ->
            drawHatCard(canvas, hatInfo, currentX, currentY, cardWidth, cardHeight)
            
            itemsInCurrentRow++
            
            if (itemsInCurrentRow >= itemsPerRow) {
                // Move to next row
                currentX = startX
                currentY += cardHeight + spacing
                itemsInCurrentRow = 0
            } else {
                // Move to next column
                currentX += cardWidth + spacing
            }
        }
    }
    
    /**
     * Draw individual hat card
     */
    private fun drawHatCard(
        canvas: Canvas,
        hatInfo: HatInfo,
        x: Float,
        y: Float,
        width: Float,
        height: Float
    ) {
        val cardRect = RectF(x, y, x + width, y + height)
        
        // Card background
        val backgroundPaint = when {
            hatInfo.isSelected -> selectedCardPaint
            hatInfo.isUnlocked -> unlockedCardPaint
            else -> lockedCardPaint
        }
        canvas.drawRoundRect(cardRect, 16f, 16f, backgroundPaint)
        
        // Rarity border
        rarityBorderPaints[hatInfo.type.rarity]?.let { borderPaint ->
            canvas.drawRoundRect(cardRect, 16f, 16f, borderPaint)
        }
        
        // Selected border
        if (hatInfo.isSelected) {
            canvas.drawRoundRect(cardRect, 16f, 16f, selectedBorderPaint)
        }
        
        // Bird sprite (larger with better positioning)
        val spriteSize = 80f
        val spriteX = x + width / 2f
        val spriteY = y + 80f
        
        if (hatInfo.isUnlocked) {
            // Draw actual sprite or enhanced placeholder
            drawHatSpritePlaceholder(canvas, spriteX, spriteY, spriteSize, hatInfo.type)
            
            // Add special effects for premium hats
            drawHatSpecialEffects(canvas, spriteX, spriteY, spriteSize, hatInfo.type)
        } else {
            // Draw locked placeholder with lock overlay
            drawHatSpritePlaceholder(canvas, spriteX, spriteY, spriteSize, hatInfo.type)
            
            // Lock overlay
            val lockRect = RectF(spriteX - spriteSize/2f, spriteY - spriteSize/2f, 
                                spriteX + spriteSize/2f, spriteY + spriteSize/2f)
            canvas.drawRoundRect(lockRect, 8f, 8f, lockOverlayPaint)
            canvas.drawText("ðŸ”’", spriteX, spriteY + 8f, lockIconPaint)
        }
        
        // Hat name with better spacing
        canvas.drawText(hatInfo.type.displayName, x + width/2f, y + 160f, hatNamePaint)
        
        // Rarity with consistent font size
        rarityTextPaint.color = Color.parseColor(hatInfo.type.rarity.color)
        canvas.drawText(hatInfo.type.rarity.displayName, x + width/2f, y + 195f, rarityTextPaint)
        
        // Achievement requirement (more visible)
        val achievementText = when {
            hatInfo.isUnlocked -> "Unlocked!"
            hatInfo.type.price.startsWith("Score:") -> hatInfo.type.price
            else -> "Unlock: ${hatInfo.type.price}"
        }
        canvas.drawText(achievementText, x + width/2f, y + 230f, hatDescPaint)
        
        // Action button (larger with better positioning)
        val buttonWidth = width * 0.85f
        val buttonHeight = 50f  // Larger button height
        val buttonX = x + (width - buttonWidth) / 2f
        val buttonY = y + height - 70f
        val buttonRect = RectF(buttonX, buttonY, buttonX + buttonWidth, buttonY + buttonHeight)
        
        when {
            hatInfo.isSelected -> {
                // Selected - show checkmark
                canvas.drawRoundRect(buttonRect, 15f, 15f, selectedCardPaint)
                canvas.drawText("âœ“ EQUIPPED", buttonX + buttonWidth/2f, buttonY + 35f, hatNamePaint)
            }
            hatInfo.isUnlocked -> {
                // Unlocked - show select button
                canvas.drawRoundRect(buttonRect, 15f, 15f, selectButtonPaint)
                canvas.drawText("SELECT", buttonX + buttonWidth/2f, buttonY + 35f, buttonTextPaint)
            }
            else -> {
                // Locked - show achievement requirement
                canvas.drawRoundRect(buttonRect, 15f, 15f, buyButtonPaint)
                val buttonText = if (hatInfo.type.price.startsWith("Score:")) "LOCKED" else hatInfo.type.price
                canvas.drawText(buttonText, buttonX + buttonWidth/2f, buttonY + 35f, buttonTextPaint)
            }
        }
    }
    
    /**
     * Draw enhanced hat sprite placeholder with hat-specific designs
     */
    private fun drawHatSpritePlaceholder(
        canvas: Canvas,
        centerX: Float,
        centerY: Float,
        size: Float,
        hatType: HatType
    ) {
        val radius = size / 2f
        
        // Get hat-specific colors and effects
        val (bodyColor, accentColor, hasSpecialEffect) = getHatVisualData(hatType)
        
        // Bird body with hat-specific styling
        bodyPaint.color = bodyColor
        // Add gradient effect for premium hats
        if (hasSpecialEffect) {
            bodyPaint.setShadowLayer(8f, 0f, 0f, accentColor)
        } else {
            bodyPaint.clearShadowLayer()
        }
        canvas.drawCircle(centerX, centerY, radius * 0.8f, bodyPaint)
        
        // Bird outline
        canvas.drawCircle(centerX, centerY, radius * 0.8f, outlinePaint)
        
        // Simple wing
        val wingPath = Path().apply {
            moveTo(centerX - radius * 0.3f, centerY)
            lineTo(centerX - radius * 0.8f, centerY - radius * 0.3f)
            lineTo(centerX - radius * 0.6f, centerY + radius * 0.2f)
            close()
        }
        canvas.drawPath(wingPath, bodyPaint)
        canvas.drawPath(wingPath, outlinePaint)
        
        // Eye
        canvas.drawCircle(centerX + radius * 0.2f, centerY - radius * 0.2f, radius * 0.15f, eyePaint)
        
        // Pupil
        canvas.drawCircle(centerX + radius * 0.25f, centerY - radius * 0.2f, radius * 0.08f, pupilPaint)
        
        // Beak
        val beakPath = Path().apply {
            moveTo(centerX + radius * 0.7f, centerY)
            lineTo(centerX + radius * 1.1f, centerY - radius * 0.1f)
            lineTo(centerX + radius * 0.7f, centerY + radius * 0.1f)
            close()
        }
        canvas.drawPath(beakPath, beakPaint)
    }
    
    /**
     * Draw close button
     */
    private fun drawCloseButton(canvas: Canvas, x: Float, y: Float) {
        val buttonSize = 80f  // Larger close button for better accessibility
        val buttonRect = RectF(x, y, x + buttonSize, y + buttonSize)
        canvas.drawRoundRect(buttonRect, 40f, 40f, closeButtonPaint)
        
        canvas.drawText("âœ•", x + buttonSize/2f, y + buttonSize/2f + 15f, closeButtonTextPaint)
    }
    
    /**
     * Get close button area for touch detection
     */
    fun getCloseButtonArea(): RectF {
        val panelWidth = screenWidth * 0.95f
        val panelHeight = screenHeight * 0.9f
        val panelX = (screenWidth - panelWidth) / 2f
        val panelY = (screenHeight - panelHeight) / 2f
        
        return RectF(
            panelX + panelWidth - 100f,  // Updated for larger button
            panelY + 30f,
            panelX + panelWidth - 20f,
            panelY + 110f                // Updated for larger button (80px height)
        )
    }
    
    /**
     * Get hat card areas for touch detection
     */
    fun getHatCardAreas(hatCount: Int): List<RectF> {
        val panelWidth = screenWidth * 0.95f
        val panelX = (screenWidth - panelWidth) / 2f
        val contentWidth = panelWidth - 40f
        val contentX = panelX + 20f
        val contentStartY = (screenHeight - screenHeight * 0.9f) / 2f + 130f
        
        val itemsPerRow = 2
        val cardWidth = (contentWidth - 40f) / itemsPerRow // More spacing
        val cardHeight = 280f  // Match the new taller cards  
        val spacing = 30f      // More spacing between cards
        
        val cardAreas = mutableListOf<RectF>()
        var currentX = contentX
        var currentY = contentStartY
        var itemsInCurrentRow = 0
        
        repeat(hatCount) {
            cardAreas.add(RectF(currentX, currentY, currentX + cardWidth, currentY + cardHeight))
            
            itemsInCurrentRow++
            
            if (itemsInCurrentRow >= itemsPerRow) {
                currentX = contentX
                currentY += cardHeight + spacing
                itemsInCurrentRow = 0
            } else {
                currentX += cardWidth + spacing
            }
        }
        
        return cardAreas
    }
    
    /**
     * Get hat-specific visual data
     */
    private fun getHatVisualData(hatType: HatType): Triple<Int, Int, Boolean> {
        return when (hatType) {
            HatType.NONE -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#4682B4"), // Steel blue
                false
            )
            HatType.BASEBALL_CAP -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#FF0000"), // Red cap color
                false
            )
            HatType.CROWN -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#FFD700"), // Gold crown
                true
            )
            HatType.WIZARD_HAT -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#9400D3"), // Violet hat
                true
            )
            HatType.VIKING_HELMET -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#4682B4"), // Steel blue helmet
                true
            )
            HatType.ROYAL_CROWN -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#FFD700"), // Gold royal crown
                true
            )
            HatType.PARTY_HAT -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#FF69B4"), // Pink party hat
                true
            )
            HatType.PIRATE_HAT -> Triple(
                Color.parseColor("#87CEEB"), // Sky blue (bird color)
                Color.parseColor("#2C1810"), // Dark brown pirate hat
                false
            )
        }
    }
    
    /**
     * Draw special effects for premium hats
     */
    private fun drawHatSpecialEffects(
        canvas: Canvas,
        centerX: Float,
        centerY: Float,
        size: Float,
        hatType: HatType
    ) {
        val radius = size / 2f
        
        when (hatType) {
            HatType.CROWN, HatType.ROYAL_CROWN -> {
                // Golden sparkles for royal hats
                // Draw small sparkles around the hat area
                for (i in 0 until 6) {
                    val angle = (i * 60f) * (Math.PI / 180f)
                    val sparkleX = centerX + (radius * 0.8f * Math.cos(angle)).toFloat()
                    val sparkleY = centerY - radius * 0.5f + (radius * 0.3f * Math.sin(angle)).toFloat()
                    canvas.drawCircle(sparkleX, sparkleY, 1.5f, sparklePaint)
                }
            }
            HatType.WIZARD_HAT -> {
                // Magical sparkles
                // Draw magical sparkles around wizard hat
                for (i in 0 until 4) {
                    val angle = (i * 90f + 45f) * (Math.PI / 180f) // Offset by 45 degrees
                    val sparkleX = centerX + (radius * 0.7f * Math.cos(angle)).toFloat()
                    val sparkleY = centerY - radius * 0.6f + (radius * 0.4f * Math.sin(angle)).toFloat()
                    canvas.drawCircle(sparkleX, sparkleY, 2f, magicPaint)
                }
            }
            HatType.PARTY_HAT -> {
                // Digital grid effect
                // Draw grid lines
                val gridSize = size / 6f
                for (i in -2..2) {
                    canvas.drawLine(
                        centerX + i * gridSize, centerY - radius,
                        centerX + i * gridSize, centerY + radius,
                        gridPaint
                    )
                    canvas.drawLine(
                        centerX - radius, centerY + i * gridSize,
                        centerX + radius, centerY + i * gridSize,
                        gridPaint
                    )
                }
            }
            HatType.VIKING_HELMET -> {
                // Nordic rune effects
                // Draw simple runic symbols around helmet
                canvas.drawLine(centerX - radius * 0.3f, centerY - radius * 0.2f, 
                               centerX + radius * 0.3f, centerY + radius * 0.2f, runePaint)
                canvas.drawLine(centerX, centerY - radius * 0.4f, 
                               centerX, centerY + radius * 0.1f, runePaint)
            }
            else -> {
                // No special effects for basic hats
            }
        }
    }
}